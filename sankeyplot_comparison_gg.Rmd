---
title: "Sankey plots with R"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

On this page I explore different R packages for building sankey plots to be integrated in an interactive Shiny app. 

The idea of this app is that the user will be able to upload their own dataset to the Shiny app, select the data columns that should be used for plotting, customise the plot as desired, and finally download a static image (png/jpg) of the plot. 

After some research and playing around with different options I decided to narrow it down to the ggalluvial and ggforce packages. 

The other packages in the running were alluvial, googleVis, riverplot, and networkD3. I disregarded each of these for one or multiple of the following reasons: 

* the data structures needed didn't seem suitable for easy reformatting of different data types
* I wasn't happy with the aesthetics of the plots
* the plot couldn't be exported as a png/jpg with the shiny downloadHandler
* the plotting functionality wasn't compatible with the ggplot2 package to extend on the styling.


```{r loadPackages}
###=================================================================================
### load in packages
library("dplyr")
library("ggplot2")
library("ggforce")
library("ggalluvial")
library("ggparallel")

```

To identify which of ggalluvial and ggforce is better suited for the task I used two datasets to create plots that make use of the functionality and plotting features of the two packages in different ways. 

This makes it easier to identify which package is preferable with respect to being able to deliver on various different desired outcomes the user might have based on the nature of the data. 

## Vote choice in the 2017 and 2019 UK general elections

For the traditional sankey plot between only two 'axes' I used polling data from the [British Election Study](https://www.britishelectionstudy.com/) about vote choice of electors in the 2017 and 2019 general elections in the UK. 

The main issue here was readability; some of the flows between the smaller UK parties are pretty small and it's important that the graph can deal with this type of data and still convey the information. There are a few other pros and cons to either package that can be summarised as follows.

**Pros and cons**

I like about the ggalluvial that the data (at least for the case of only two axes) just needs to be in an easy frequency table format (i.e.vote choice in 2017 - vote choice in 2019 - frequency); this is easy to understand and easy to achieve with most loaded in dataformats. It's also nice that the plot recognises the ggfittext::geom_fit_text function to resize the font size of the labels and therefore automatically fit the labels onto the strata.

However, from a readibility point of view the ggforce package wins. Because there are no gaps between the strata in the ggalluvial plot, it's considerably more difficult to distinguish the source and target categories (i.e. parties) of the flows, especially for the smaller categories.

In both packages it's straightforward to assign the desired colouring options and to change the order of the strata depending on factor levels of the variables. 

### Prepare data and specify plot options

```{r prepareDataTwoAxes}
###=================================================================================
### define factor levels to specify order of strata
fct_levels <- c("Labour", "Conservative", "Liberal Democrat", "UKIP", 
                "Brexit Party", "Green Party", "SNP", "Plaid Cymru")

###=================================================================================
### define plot colours
colours <- c("#DC241f", "#0087DC", "#FAA61A", "#70147A", 
            "#12B6CF", "#528D6B", "#FDF38E", "#008142")
names(colours) <- fct_levels

###=================================================================================
### format data
dat_17_19 <- read.csv("sankey_data.csv")

dat_17_19_ggalluvial <- dat_17_19 %>% 
  mutate_at(vars(vote17, vote19),
            funs(factor(., levels = fct_levels)))

dat_17_19_ggforce <- dat_17_19  %>%
  gather_set_data(1:2) %>%
  arrange(x,vote19,desc(vote17)) %>% 
  mutate_at(vars(vote17, vote19, y),
            funs(factor(., levels = fct_levels)))

###=================================================================================
### define plot settings
stratum_width <- 0.3
stratum_font_colour <- "black"
stratum_fill_colour <- "white"
stratum_line_colour <- "black"
stratum_angle <- 0
legend_position <- ""
alpha <- 0.7
```

### ggalluvial

```{r, results='asis',fig.width = 10, fig.height = 7}
ggplot(dat_17_19_ggalluvial,
       aes(y = freq, axis1 = vote17, axis2 = vote19)) +
  geom_alluvium(aes(fill = vote17, color = vote17),
                width = stratum_width, 
                alpha = alpha, 
                knot.pos = 0.4) +
  geom_stratum(width = stratum_width,
               fill = stratum_fill_colour, 
               colour = stratum_line_colour) +
  ggfittext::geom_fit_text(infer.label = TRUE, 
                           stat = "stratum", 
                           width = stratum_width,
                           colour = stratum_font_colour,
                           fontface = "bold",
                           min.size = 3) +
  scale_fill_manual(values = colours) +
  scale_color_manual(values = colours) +
  scale_x_continuous(breaks = 1:2, labels = c("GE vote 2017", "GE vote 2019")) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title  = element_blank()
  )
```


### ggforce


```{r, results='asis', fig.width = 10, fig.height = 7}
ggplot(dat_17_19_ggforce, aes(x = x, id = id, split = y, value = freq)) +
  geom_parallel_sets(aes(fill = vote17), 
                     alpha = alpha, 
                     axis.width = stratum_width,
                     n=1000) +
  geom_parallel_sets_axes(axis.width = stratum_width, 
                          fill = stratum_fill_colour,
                          color = stratum_line_colour, 
                          size = 0.3) +
  geom_parallel_sets_labels(colour = stratum_font_colour, 
                            size = 3, 
                            angle = stratum_angle, 
                            fontface="bold") +
  scale_fill_manual(values  = colours) +
  scale_color_manual(values = colours) +
  scale_x_discrete(labels = c("GE vote 2017", "GE vote 2019")) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title  = element_blank()
  )
```

## Titanic

For the case of more than two axes I used the famous titanic dataset that is built into R. Obviously the data here doesn't represent change over time but tries to represent multiple (in this case demographical) dimensions on a 2D plot by plotting the frequencies as flows between them.

Because the outcome variable in the titanic dataset is whether or not a person survived the crash, this variable is visualised as an 'extra' dimension additional to the axes in the sankey plot, namely a distinction by colour.

The main challenge of creating these plots was to understand the dataformat in which the ggalluvial plot needs the data to be. As it turns out, the data format for ggforce and ggalluvial is nearly the same when we're using the packages to plot more than two axes. I could have used the same simple version as above for the ggalluvial plot; however, for that version one needs to specify each axis separately in the aes() part of the ggplot command (i.e. axis1 = 'Class, axis2 = 'Sex', axis3 = 'Age'). Because I want to automate the data formatting for these plots in the shiny app I have to use the option that uses the same data format as ggforce.

Things I noticed as I was creating these sankey plots:

**Pros and cons**

With only two different colours the readability of the ggalluvial plot is considerably improved. The fact that there is no white space between the stratum actually has the advantage that it causes all three axes to be the same height; it would be nice if there was an option to equalise the height of the axes in ggforce (so far I haven't found a way to do so). 

However, I still think overall that the separation of the strata in ggforce means the readability of ggforce is slightly ahead of that of ggalluvial.

### Prepare data and specify plot options

```{r prepareDataMoreAxes}
###=================================================================================
### define factor levels to specify order of strata
fct_levels_class <- c("1st", "3rd", "2nd", "Crew")
fct_levels_sex <- c("Male", "Female")

###=================================================================================
### format data
dat <- Titanic %>% 
  as.data.frame() %>%
  mutate(Class = factor(Class, levels = fct_levels_class))

dat_plot <- to_lodes_form(as.data.frame(dat),
                                      axes = 1:3,
                                      id = "id")

###=================================================================================
### define plot settings
stratum_width = 0.4
stratum_font_colour = "white"
stratum_fill_colour = "black"
stratum_line_colour = "white"
stratum_angle = 0
legend_position = "right"
alpha <- 0.7
```

### ggalluvial

```{r, results='asis',fig.width = 10, fig.height = 7}
ggplot(dat_plot,
       aes(x = x, stratum = stratum, alluvium = id,
           y = Freq, label = stratum, fill = Survived)) +
  geom_lode(width = stratum_width) +
  geom_flow(width = stratum_width) +
  geom_stratum(width = stratum_width, 
               alpha = 1, 
               fill = stratum_fill_colour, 
               colour = stratum_line_colour) +
  geom_text(stat = "stratum", colour = stratum_font_colour) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold")
  )
```


### ggforce


```{r, results='asis', fig.width = 10, fig.height = 7}
ggplot(dat_plot, aes(x = x, id = id, split = stratum, value = Freq)) +
  geom_parallel_sets(aes(fill = Survived), alpha = alpha, axis.width = stratum_width) +
  geom_parallel_sets_axes(axis.width = stratum_width, 
                          fill = stratum_fill_colour,
                          colour = stratum_fill_colour) +
  geom_parallel_sets_labels(colour = stratum_font_colour, angle = stratum_angle) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title.x  = element_blank()
  )

```

## Summary

After playing around with the two packages for a while and having tried to get them to display very similar results for the different datasets my conclusion is that while they're both reasonable options for the desired outcome, I have a slight preference for the ggforce package. 

This is partly because I find it more aesthetically pleasing but mainly because it has slightly superior readability than the plots from ggalluvial, both for a larger number of colours and for a larger number of overall categories.

There are a few pros and cons that either packages have (axis labels, sizing, proportions) that might become more or less of a problem when I try to implement them in Shiny. For now, my plan is to start with the Shiny app using ggforce based on the preference I have from the work that went into the plots on this page, but keep ggalluvial as an option to fall back on. 

In general, it's worth adding that there are few things that I'm missing in both packages:

* For the two-axes example, it would be nice to be able to have the option to split the colour of the strata separately for each axis and then set a colour gradient between the strata for those flows that don't have the same source and target (for example a red-blue gradient for those voters that changed from Labour to Conservative).
* In all cases, it would be nice to have more flexibility (and definitely easier handling) with respect to the length and width of the flows and the overall shape of the plots.

It's possible that options exist to achieve these things - some more research is definitely required. Building my own extensions to achieve some of these additional features is also a potential at some point further down the line.