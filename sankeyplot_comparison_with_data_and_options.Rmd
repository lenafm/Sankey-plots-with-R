---
title: "Sankey plots with R"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

On this page I explore different R packages for building sankey plots to be integrated in an interactive Shiny app. 

The idea of this app is that the user will be able to upload their own dataset to the Shiny app, select the data columns that should be used for plotting, customise the plot as desired, and finally download a static image (png/jpg) of the plot. 

After some research and playing around with different options I decided to narrow it down to the ggalluvial and ggforce packages. 

The other packages in the running were alluvial, googleVis, riverplot, and networkD3. I disregarded each of these for one or multiple of the following reasons: 

* the data structures needed didn't seem suitable for easy reformatting of different data types
* I wasn't happy with the aesthetics of the plots
* the plot couldn't be exported as a png/jpg with the shiny downloadHandler
* the plotting functionality wasn't compatible with the ggplot2 package to extend on the styling.


```{r loadPackages}
library("dplyr")
library("ggplot2")
library("ggforce")
library("ggalluvial")
library("ggparallel")
```

To identify which of ggalluvial and ggforce is better suited for the task I used two datasets to create plots that make use of the functionality and plotting features of the two packages in different ways. 

This makes it easier to identify which package is preferable with respect to being able to deliver on various different desired outcomes the user might have based on the nature of the data. 

## Vote choice in the 2017 and 2019 UK general elections

For the traditional sankey plot between only two 'axes' I used polling data from the [British Election Study](https://www.britishelectionstudy.com/) about vote choice of electors in the 2017 and 2019 general elections in the UK. 

The main issue here was readability; some of the flows between the smaller UK parties are pretty small and it's important that the graph can deal with this type of data and still convey the information. There are a few other pros and cons to either package that can be summarised as follows.

**Pros and cons**

I like about the ggalluvial that the data (at least for the case of only two axes) just needs to be in an easy frequency table format (i.e.vote choice in 2017 - vote choice in 2019 - frequency); this is easy to understand and easy to achieve with most loaded in dataformats. It's also nice that the plot recognises the ggfittext::geom_fit_text function to resize the font size of the labels and therefore automatically fit the labels onto the strata.

However, from a readibility point of view the ggforce package wins. Because there are no gaps between the strata in the ggalluvial plot, it's considerably more difficult to distinguish the source and target categories (i.e. parties) of the flows, especially for the smaller categories.

In both packages it's straightforward to assign the desired colouring options and to change the order of the strata depending on factor levels of the variables. 

### Prepare data

To prepare the data to work with the alluvial plots, it first needs to be converted to a format of one row per "cohort" of observations, with a final frequency column that specifies the number of observations in the cohort. This is assuming the input data will be in the "raw" format of one row per observation.

The user first chooses the column names from the raw data that will be the "axes" along the x-axis between which the flows will be plotted. The user can then (optionally) also choose a fill variable to choose the colouring of the flows, as well as an ordering of the strata. This will be shown further down.

In this example, the original data consists of one row per voter, with one column for their vote choice in 2017 (vote17) and one for their vote choice in 2019 (vote19). The two "axes" between we want to display the flows are "vote17" and "vote19", so we need to group the original dataframe by those two columns to calculate the frequency for each "cohort". The user input would therefore specify these two columns:

```{r chooseColumns, echo = TRUE}
cols_input = c("vote17", "vote19")
```

From the raw data the format can easily be converted to the frequency table by using dplyr's `group_by` functionality, using `cols_input` as grouping variables.

In this case, the data was already grouped before. It would then, after grouping, look as follows:

```{r showData, echo = TRUE}
dat_17_19 <- read.csv("sankey_data.csv")
head(dat_17_19)
```

To achieve the desired format for the sankey plots, we first add an `id` column, that gives a unique ID to each cohort. As one row in the frequency table represents one cohort, we can use row numbers to create this ID.

We then use tidyr's `gather` function, to convert the data to the format needed for `ggforce` and `ggalluvial`:

```{r manipulateDataTwoAxes}
dat <- dat_17_19 %>% 
  mutate(id = row_number())

dat_plot <- dat %>%
  tidyr::gather(key = "x",
                value = "stratum",
                vote17, vote19)

head(dat_plot)
```

In this format, the data now has one row **for each stratum**. In this example, this means that there are two rows for each cohort (`id`), one showing the 2017 vote choice and one showing the 2019 vote choice. We can see this if we sort by the `id` column:

```{r arrangeDataTwoAxes}
head(dat_plot %>% arrange(id))
```

### Prepare Plot styling options

Now that we have the data in the right format, we can specify some styling parameters for the plots. Some or all of these could be specified by the user (especially the labels). There are more options for making it possible for the user to change any of the standard `ggplot` settings (font type, size, text, etc of the labels, titles and so on).

```{r preparePlotStylingTwoAxes}
stratum_width <- 0.3
stratum_font_colour <- "black"
stratum_fill_colour <- "white"
stratum_line_colour <- "black"
stratum_angle <- 0
legend_position <- ""
alpha <- 0.7
labels = c("GE vote 2017", "GE vote 2019")
```


### Plotting functions

The plot functions are passed the `dat_plot` dataframe and the relevant columns. The code and output then looks as follows:

#### ggalluvial

```{r, results='asis', fig.width = 10, fig.height = 7}
  ggplot(dat_plot,
       aes(x = x, 
           stratum = stratum, 
           alluvium = id,
           y = freq, 
           label = stratum)) +
  geom_lode(width = stratum_width) +
  geom_flow(width = stratum_width) +
  geom_stratum(width = stratum_width,
               fill = stratum_fill_colour, 
               colour = stratum_line_colour) +
  ggfittext::geom_fit_text(stat = "stratum", 
                           width = stratum_width,
                           colour = stratum_font_colour,
                           fontface = "bold",
                           min.size = 3) +
  scale_x_discrete(labels = labels) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title  = element_blank()
  )
```

#### ggforce


```{r, results='asis', fig.width = 10, fig.height = 7}
ggplot(dat_plot, aes(x = x, id = id, split = stratum, value = freq)) +
  geom_parallel_sets(alpha = alpha, 
                     axis.width = stratum_width,
                     n=1000) +
  geom_parallel_sets_axes(axis.width = stratum_width, 
                          fill = stratum_fill_colour,
                          color = stratum_line_colour, 
                          size = 0.3) +
  geom_parallel_sets_labels(colour = stratum_font_colour, 
                            size = 3, 
                            angle = stratum_angle, 
                            fontface="bold") +
  scale_x_discrete(labels = labels) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title  = element_blank()
  )
```

### Change order of strata and colours

Now, what if we want the flows to be shown in a certain order? And if we want the flows to be coloured depending on a certain variable in the data? 

For the colouring part of this, the fill variable needs to be part of the frequency table that we create from the raw data by grouping it. In this case, the fill variable is one of the two columns that were used to create the frequency table anyway. However, as we will see in the example below, that doesn't need to be the case. When it is an additional variable that the flow colours are filled by, the grouping of the raw data needs to conditionally include the extra fill variable when it was specified by the user. 

Before we prepare the data for this case, we show the parameters specified for the ordering of the strata and the colour vector. 

In this case, the user has chosen that the vote17 axis should be ordered as specified by `fct_levels17` and the vote19 axis is ordered by `fct_levels19`. In order for the ordering to work, we then need to create one combined level vector from those two vectors (denoted `fct_levels_all` in the code below). 

Note that this could be an issue if the user only chooses the order of one of the axes. In that case we need to specify that the code uses the automatic (alphabetical) ordering of the levels of the other axis (or axes if there are more than two overall) if no ordering is specified.

```{r prepareFactors}
###=================================================================================
### define factor levels to specify order of strata
fct_levels <- c("Labour", "Conservative", "Liberal Democrat", "UKIP", 
                "Brexit Party", "Green Party", "SNP", "Plaid Cymru")
fct_levels17 <- paste0(fct_levels, "17")
fct_levels19 <- paste0(fct_levels, "19")
fct_levels_all <- c(fct_levels17, fct_levels19)
fct_levels_all
```

For our plots, we want the flows to be coloured by the official colours of the political parties according to the 2017 vote choice. The colour vector needs to have one colour for each level and is then named according to the factor levels of the specified column. In the app, this will look differently, as the user should be able to directly choose a colour for each level, *or* choose a colour palette if preferred. This part here is to show what the colour vector needs to look like for plotting.

```{r prepareColours}
###=================================================================================
### define plot colours
colours <- c("#DC241f", "#0087DC", "#FAA61A", "#70147A", 
            "#12B6CF", "#528D6B", "#FDF38E", "#008142")
names(colours) <- fct_levels17
colours
```

To reflect these optional user input parameters, the data formatting needs to have two extra steps. These will be conditional to the user having specified any of the optional parameters.

The left join in the following `dplyr` pipe ensures that the necessary fill variable is included in the data frame. The mutate at ensures that the strata are displayed in the order that was defined by the user. Again, this will only be necessary if the user has specified an order. 

```{r prepareDataTwoAxes}
### format data
dat <- dat_17_19 %>% 
  mutate(id = row_number())

dat_plot <- dat %>%
  tidyr::gather(key = "x",
                value = "stratum",
                factor_key = TRUE,
                vote17, vote19) %>% 
  left_join(dat %>%
              mutate(fill = vote17) %>% 
              select(id, fill),
            by = "id") %>%
  mutate_at(vars(stratum),
            funs(factor(., levels = fct_levels_all)))

head(dat_plot)
```

### Plotting functions (with ordering and colours)

We can see that with these extra parameters, the flows are now ordered according to the defined factor levels and coloured by the 2017 vote choices.

#### ggalluvial

```{r, results='asis', fig.width = 10, fig.height = 7}
  ggplot(dat_plot,
       aes(x = x, stratum = stratum, alluvium = id,
           y = freq, label = stratum, fill = fill)) +
  geom_lode(width = stratum_width) +
  geom_flow(width = stratum_width) +
  geom_stratum(width = stratum_width,
               fill = stratum_fill_colour, 
               colour = stratum_line_colour) +
  ggfittext::geom_fit_text(stat = "stratum", 
                           width = stratum_width,
                           colour = stratum_font_colour,
                           fontface = "bold",
                           min.size = 3) +
  scale_fill_manual(values = colours) +
  scale_color_manual(values = colours) +
  scale_x_discrete(labels = labels) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title  = element_blank()
  )
```

#### ggforce


```{r, results='asis', fig.width = 10, fig.height = 7}
ggplot(dat_plot, aes(x = x, id = id, split = stratum, value = freq)) +
  geom_parallel_sets(aes(fill = fill), 
                     alpha = alpha, 
                     axis.width = stratum_width,
                     n=1000) +
  geom_parallel_sets_axes(axis.width = stratum_width, 
                          fill = stratum_fill_colour,
                          color = stratum_line_colour, 
                          size = 0.3) +
  geom_parallel_sets_labels(colour = stratum_font_colour, 
                            size = 3, 
                            angle = stratum_angle, 
                            fontface="bold") +
  scale_fill_manual(values  = colours) +
  scale_color_manual(values = colours) +
  scale_x_discrete(labels = labels) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title  = element_blank()
  )
```


## Titanic

For the case of more than two axes I used the famous titanic dataset that is built into R. Obviously the data here doesn't represent change over time but tries to represent multiple (in this case demographical) dimensions on a 2D plot by plotting the frequencies as flows between them.

Because the outcome variable in the titanic dataset is whether or not a person survived the crash, this variable is visualised as an 'extra' dimension additional to the axes in the sankey plot, namely a distinction by colour.

The main challenge of creating these plots was to understand the dataformat in which the ggalluvial plot needs the data to be. As it turns out, the data format for ggforce and ggalluvial is nearly the same when we're using the packages to plot more than two axes. I could have used the same simple version as above for the ggalluvial plot; however, for that version one needs to specify each axis separately in the aes() part of the ggplot command (i.e. axis1 = 'Class, axis2 = 'Sex', axis3 = 'Age'). Because I want to automate the data formatting for these plots in the shiny app I have to use the option that uses the same data format as ggforce.

Things I noticed as I was creating these sankey plots:

**Pros and cons**

With only two different colours the readability of the ggalluvial plot is considerably improved. The fact that there is no white space between the stratum actually has the advantage that it causes all three axes to be the same height; it would be nice if there was an option to equalise the height of the axes in ggforce (so far I haven't found a way to do so). 

However, I still think overall that the separation of the strata in ggforce means the readability of ggforce is slightly ahead of that of ggalluvial.

### Prepare data and specify plot options

```{r prepareDataMoreAxes}
###=================================================================================
### define factor levels to specify order of strata
fct_levels_class <- c("1st", "3rd", "2nd", "Crew")
fct_levels_sex <- c("Male", "Female")

###=================================================================================
### format data
dat <- Titanic %>% 
  as.data.frame() %>%
  mutate(id = row_number())

dat_plot <- dat %>%
  tidyr::gather(key = "x",
                value = "stratum",
                factor_key = TRUE,
                Class, Sex, Age) %>% 
  left_join(dat %>%
              mutate(fill = Survived) %>% 
              select(id, fill),
            by = "id")

###=================================================================================
### define plot settings
stratum_width = 0.4
stratum_font_colour = "white"
stratum_fill_colour = "black"
stratum_line_colour = "white"
stratum_angle = 0
legend_position = "right"
alpha <- 0.7
```

### ggalluvial

```{r, results='asis',fig.width = 10, fig.height = 7}
ggplot(dat_plot,
       aes(x = x, stratum = stratum, alluvium = id,
           y = Freq, label = stratum, fill = fill)) +
  geom_lode(width = stratum_width) +
  geom_flow(width = stratum_width) +
  geom_stratum(width = stratum_width, 
               alpha = 1, 
               fill = stratum_fill_colour, 
               colour = stratum_line_colour) +
  geom_text(stat = "stratum", colour = stratum_font_colour) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold")
  )
```


### ggforce


```{r, results='asis', fig.width = 10, fig.height = 7}
ggplot(dat_plot, aes(x = x, id = id, split = stratum, value = Freq)) +
  geom_parallel_sets(aes(fill = fill), alpha = alpha, axis.width = stratum_width) +
  geom_parallel_sets_axes(axis.width = stratum_width, 
                          fill = stratum_fill_colour,
                          colour = stratum_fill_colour) +
  geom_parallel_sets_labels(colour = stratum_font_colour, angle = stratum_angle) +
  theme_minimal() +
  theme(
    legend.position = legend_position,
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, face = "bold"),
    axis.title.x  = element_blank()
  )

```

## Summary

After playing around with the two packages for a while and having tried to get them to display very similar results for the different datasets my conclusion is that while they're both reasonable options for the desired outcome, I have a slight preference for the ggforce package. 

This is partly because I find it more aesthetically pleasing but mainly because it has slightly superior readability than the plots from ggalluvial, both for a larger number of colours and for a larger number of overall categories.

There are a few pros and cons that either packages have (axis labels, sizing, proportions) that might become more or less of a problem when I try to implement them in Shiny. For now, my plan is to start with the Shiny app using ggforce based on the preference I have from the work that went into the plots on this page, but keep ggalluvial as an option to fall back on. 

In general, it's worth adding that there are few things that I'm missing in both packages:

* For the two-axes example, it would be nice to be able to have the option to split the colour of the strata separately for each axis and then set a colour gradient between the strata for those flows that don't have the same source and target (for example a red-blue gradient for those voters that changed from Labour to Conservative).
* In all cases, it would be nice to have more flexibility (and definitely easier handling) with respect to the length and width of the flows and the overall shape of the plots.

It's possible that options exist to achieve these things - some more research is definitely required. Building my own extensions to achieve some of these additional features is also a potential at some point further down the line.